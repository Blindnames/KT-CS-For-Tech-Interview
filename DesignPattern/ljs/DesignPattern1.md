디자인 패턴
디자인 패턴이란?

프로그램을 설계할 떄 발생했던 문제점들을 객체 가느이 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약'  형태

​

디자인 패턴 의의

협업할 때 문제가 발생 시 빠른 의사소통 가능

​

라이브러리란?

공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것

폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움

​

프레임워크란?

공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것

폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격함

​

디자인 패턴의 종류

생성 패턴

구조 패턴

행동 패턴

​

생성 패턴

객체 생성 방법이 들어간 디자인 패턴

싱글톤, 팩토리, 추상팩토리, 빌더, 프로토타입 패턴

​

구조 패턴

객체, 클래스 등으로 큰 구조를 만들 때 유연하고 효율적으로 만드는 방법이 들어간 디자인 패턴

프록시, 어댑터, 브리지, 복합체, 데코레이터, 퍼사드, 플라이웨이트 패턴

​

행동 패턴

객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴

이터레이터, 오벚버, 전략, 책입연쇄, 커맨드, 중재자, 머멘토, 상태, 템플릿메서드, 비지터 패턴



디자인 패턴 - 싱글톤 패턴
싱글톤 패턴이란?

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

​

장점 : 비용이 적고 인스턴스 생성에 좋음

단점 : 의존성이 높아짐, TDD에 단점

​

TDD란?

Test Driven Development, 단위 테스트

단위 테스트는 서로 독립적이여야 하며 테스트를 어떤 순서로든 실행 가능해야 함

싱글톤 패턴을 구현하는 7가지 방법

단순한 메서드 호출

싱글톤 패턴 생성 여부를 확인하고 싱글톤이 없으면 새로 만들고 있다면 만들어진 인스턴스 반환

​

문제점 

이 코드는 메서드의 원자성 결여

​

2. synchronized

스레드가 해당 메서드 호출시에 다른 스레드가 접근하지 못하도록 잠금(lock)

​

문제점

getInstance()메서드를 호출할 때마다 lock이 걸려 성능저하

​

3. 정적 멤버

정적(static)멤버나 블록은 런타임이 아니라 최초에 JVM이 클래스 로딩 때 모든 클래스들을 로드할 때 미리 인스턴스를 생성하는데 이용한 방법

클래스 로딩과 동시에 싱글톤 인스턴스 생성

→ 그래서 인스턴스 요청시 만들어진 인스턴스 반환

​

문제점

싱글톤 인스턴스가 필요없는 경우도 무조건 싱글톤 클래스 호출 → 자원낭비

​

4. 정적 블록

정적(static) 블록 사용

​

5. 정적 멤버와 Lazy Holder(중첩 클래스) (★추천★)

singleInstanceHolder라는 내부 클래스 하나 더 생성하여 Singleton클래스가 최초에 로딩되더라도 함께 초기화 되지 않고 getInstance()가 호출될 때 singleInstanceHolder클래스가 로딩되어 인스턴스 생성

​

6. 이중 확인 잠금(DCL)

인스턴스 생성 여부를 싱글톤 패턴 잠금 전에 한번, 객체를 생성하기 전에 한번 → 총 2번 체크

하여 인스턴스가 존재하지 않을 때만 잠금을 걸 수 있기에 앞선 문제점들 해결

​

7. enum (★추천★)

스레드세이프(thread safe)한 점이 보장되기 때문에 이를 통해 생성

​

스레드 세이프란 

멀티 스레드로 동작하는 프로그램에서 복수의 스레드로부터 호출되더라도 기대대로 동작하는 것

​

→ 5번과 7번을 추천하는 이유

5번은 가장 많이 쓰임

7번은 이펙티브 자바를 쓴 조슈아 블로크가 추천한 방법


디자인 패턴 - 팩토리 패턴

팩토리 패턴이란?

객체 생성 부분을 떼어내 추상화한 패턴

상속 관계에서 상위 클래스가 중요한 뼈대결정, 하위 클래스에서 객체 생성의 내용 결정

​

이터레이터 패턴이란?

이터레이터(iterator)를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴

​

장점 : 다른 컬렉션들을 똑같은 인터페이스로 순회하는데 쉬움

​

의존성주입 (Dependency Injection)이란

메인모듈이 간접적으로 의존성을 주입하는 방식

메인 모듈과 하위모듈간의 의존성을 조금 느슨하게 만들어 모듈을 쉽게 교체 가능한 구조로 생성

​

'의존한다'의 의미

A가 B에 의존한다 : A → B

B가 변하면 A도 영향을 미친다.

import java.util.;
class B{
    public void go(){
        System.out.println("B의 go()함수");
    }
}
class A{
    public void go(){
        new B().go();
    }
}
public class main(){
    public static void main(String args[]){
        new A().go();
    }
}
​

의존관계역전원칙이란?

의존성 주입을 할 떄는 의존관계역전원칙이 적용

​

2가지 규칙 

상위 모듈은 하위모듈에 의존해선 안된다. 

둘 다 추상화에 의존

추상화는 세부사항에 의존해서는 안된다.

세부 사항은 추상화에 따라 달라져야 한다.

​

​


 

화살표가 연전되어 의존관계역전원칙

의존성 주입의 장점

외부에서 모듈을 생성하여 집어넣는 구조이기 때문에 모듈들을 쉽게 교체 가능

단위 테스팅과 마이그레이션 유용

애플리케이션 의존성 방향이 좀 더 일관되어 코드 추론에 유용

​

의존성 주입의 단점

모듈들이 많아져 복잡도 증가

종속성 주입이 런타임때 일어나기 때문에 컴파일을 할 때 종속성 주입에 관한 에러를 잡기 어렵다.