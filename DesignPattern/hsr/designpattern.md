### `전략 패턴`


### `옵저버 패턴(Observer Pattern)`

주체가 어떤 객체(Subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려 주는 디자인 패턴

* 주체 : 객체의 상태 변화를 보고 있는 관찰자
* 옵저버 : 객체의 상태 변화에 따라 전달되는 메서드등을 기반으로 ‘추가 변화 사항’이 생기는 객체들

`ex) 트위터 : 어떤 사람이 주체를 ‘팔로우’했다면 주체가 포스팅을 올리게 되면 알림이 ‘팔로우’에게 간다. MVC 패턴에도 사용된다.`


### `프록시 패턴(Proxy Pattern)`

대상 객체(Subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체의 앞단의 인터페이스 역할을 하는 디자인 패턴

객체의 속성, 변환 등을 보완하며 **보안, 데이터 검증, 캐싱, 로깅**에 사용한다. 

`ex) 프록시 서버 : 프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.`

---

# _MVC MVP MVVM 패턴_

### `MVC 패턴`

MVC패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴

`ex) Spring`

* **모델** : 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함. 뷰에서 데이터를 생성하거나 수정할 때 컨트롤러를 통해 모델이 생성 또는 업데이트 된다.
* **뷰** : 사용자 인터페이스 요소를 나타내며 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다.
* **컨트롤러** : 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다.

#### 장점

* 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다.
* 재사용성과 확장성이 용이하다는 장점이 있다.

#### 단점

* 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다.

### `MVP 패턴`

C(controller)가 P(프레젠터, presenter)로 교체된 패턴. V와 P는 1:1 관계이므로 MVC보다 더 강한 결합을 지닌 디자인 패턴.

### `MVVM 패턴`

C(controller)가 VM(뷰 모델, view model)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM : V = 1 : N 이라는 관계를 가짐. 

`ex) View.js`

VM은 커맨드와 데이터바인딩을 가진다.

* 커맨드 : 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
* 데이터바인딩 : 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법

| 특징 | MVC 패턴 | MVP 패턴 | MVVM 패턴 |
|:---:|:---:|:---:|:---:|
| 관계 | 컨트롤러와 뷰는 1:n | 프레젠터와 뷰는 1:1 | 뷰모델과 뷰는 1:n |
| 참조 &nbsp;| 뷰는 컨트롤러를 참조 X | 뷰는 프레젠터를 참조 O | 뷰는 모델을 참조 O |

---

# _Flux Pattern_

MVC패턴의 한계로 페이스북이 만듦. 단방향 데이터 흐름을 활용하여 복잡한 뷰 구성을 단순화한 디자인 패턴. action, dispatcher, store이라는 계층이 있음. 데이터 일관성이 늘어나고 버그를 찾기 쉬워지며 단위테스팅이 쉬워지는 장점이 있음.

* Action : 마우스 클릭이나, 글을 쓴다던가 이벤트를 의미하며 이벤트가 발생했을 때 action에 관한 객체를 만들어내 dispatcher에게 전달.
* Dispatcher : Dispatcher는 들어오는 Action 객체 정보를 기반 어떠한 ‘행위’를 할 것인가.
* Store : 데이터, 상태를 담고 있는 계층.

