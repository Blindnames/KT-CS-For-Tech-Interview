# 4주 차 IP주소

---

## *IP주소, MAC주소, ARP, RARP*

### IP주소 (Internet Protocol address)

> 논리적 주소이며 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.
> 

<aside>
💡 **물리적 주소, 논리적 주소**

**물리적 주소(Physical Address)** : 네트워크 장비의 고유한 주소로 ***MAC주소***라고도 불린다. 컴퓨터와 네트워크 장비들이 통신할 때 데이터를 보내고 받는 데 사용된다.

**논리적 주소(Logical Address)** : ***IP주소***와 같은 주소 체계를 의미, 논리적 주소는 데이터를 보내고 받는 데 사용되며, 네트워크 장비들이 네트워크 상에서 서로를 식별하는 데 사용된다.

</aside>

IP를 기반으로 통신한다고 하지만 사실상 그 밑에 물리적 주소인 MAC 주소를 통해 통신한다.

IP주소 밑에 MAC주소가 있다. 

ex) 스타벅스와 이디야의 와이파이로 연결하면 IP주소는 다르지만 노트북의 MAC주소는 같다.

### **MAC 주소(Media Access Contorl ddress)**

> 네트워크 인터페이스 카드(NIC, LAN카드)에 할당된 **고유 식별자**이다.
> 

- NIC
    
    컴퓨터를 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치, 네트워크 카드, 랜 카드, 물리 네트워크 인터페이스라고도 한다.
    

48비트로 이루어져 있으며 24비트의 OUI와 24비트의 UAA로 이루어져 있다.

- OUI : IEEE에서 할당한 제조사 코드
- UAA : 제조사에서 구별되는 코드

같은 네트워크 상에서 두 개 이상의 장치가 동일한 MAC주소를 가지는 경우 충돌이 발생하므로 고유한 값이어야 하며 이를 보장하기 위해 IEEE(Institute of Electrical and Electronics Engineers)에서 MAC주소 할당 규칙을 정해두고 있다.

### **ARP와 RARP**

> 논리적 주소와 물리적 주소 사이의 변환을 담당하는 프로토콜
> 

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled.png)

### **ARP**

> 논리적 주소인 IP 주소를 물리적 주소인 MAC 주소로 변환
> 

1. 해당 IP주소에 맞는 MAC주소를 찾기 위해 해당 데이터를 브로드캐스팅을 통해 연결된 네트워크에 있는 장치한테 모두 보낸다.
2. 맞는 장치가 있다면 해당 장치는 보낸 장치에게 유니캐스트로 데이터를 전달해 주소를 찾게 된다. (요청한 MAC주소 정보 전달)

<aside>
💡 **브로드캐스팅, 유니캐스트**

**브로드캐스팅** : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식

**유니캐스트** : 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 트래픽 또는 메시지를 전송하는 방식

</aside>

### RARP

> 물리적 주소인 MAC 주소를 논리적 주소인 IP 주소로 변환
> 

---

## ***IP주소 체계 1. 이진수 이해하기***

우리가 평소에 표현하는 수는 0~9라는 수를 기반으로 수를 표현하는 ‘**십진법**’이다.

123이라는 수를 십진수로 표현하기 => 123 = 1*10^2 + 2*10^1 + 3*10^0

각각의 자리를 0~9로 10개의 숫자로 표현한다. 

**이진법**은 0과 1 두개의 숫자로 표현하게 되며 표현하는 수가 바로 **이진수**라고 한다.

이진법의 수를 십진법의 수와 구별하기 위한 표현법

- 100101b (binary)
- 100101(2)
- 0b100101

10110101 = 1*2^7 + 0*2^6 + 1*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 181

| 십진수 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 이진수 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

---

## ***IP주소 체계 2. IPv4와 IPv6***

IP주소는 인터넷 주소로 IPv4와 IPv6로 나눠짐. (버전이 2개)

### **IPv4**

- 32비트, 2^32개의 주소(41억 9천만 주소)로 표현
- 8비트 단위(옥텟)로 점을 찍어 4개로 구분(4개의 옥텟), 8비트를 10진수로 표현
- IPv4로 주소를 모두 표현하기에는 부족하므로 NAT, 서브네팅 여러 개의 부수적인 기술이 필요

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%201.png)

### **IPv6**

- 128비트, 2^128개의 주소 표현(많은 주소 처리가 가능하며 NAT, 서브네팅이 필요하지 않음.)
- 16비트씩 8개로 구분, 16비트는 16진수로 변환되어 콜론(:)으로 구분하여 표시하며 앞의 연속되는 0은 생략될 수 있다.

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%202.png)

- 앞 64비트 : 네트워크 주소, 뒤 64비트 : 인터페이스 주소(Host)
- IPSec(데이터 패킷을 암호화 하는 보안 네트워크 프로토콜 제품군)이 내장되어 있음. (보안 강화)

### **IPv4와 IPv6의 헤더 차이**

- IP헤더란?
    
    IP 헤더는 패킷이 인터넷을 통해 어디로 여행할지 알고있는 방법이다. IP 버전, 패킷의 길이, 소스 및 대상과 같은 정보를 표시한다.
    

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%203.png)

1. **IPv6의 단순한 헤더 포맷**
    
    IPv6은 IPv4 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능
    
2. **IPv4는 체크섬이 있지만 IPv6는 체크섬이 없다.**
    
    IPv4는 CRC(순환 중복 검사)를 통한 손상된 패킷을 확인하고 폐기하는데 쓰는 체크섬 필드가 있다.
    
    IPv6는 헤더의 효율화를 위해 CRC를 제외한다. 상위 프로토콜(TCP, UDP)에서 이미 체크섬이 있기 때문에 이를 제거할 수 있다.
    
3. 이외에도 **IPv4는 헤더가 가변길이(옵션 필드)지만 IPv6는 고정길이**(40바이트)라서 ‘인터넷 헤더길이’에 대한 정보, 식별, 플래그 등이 삭제되었다. (불필요한 정보 삭제)

### **CRC(Cyclic Redundancy Check)**

> 순환 중복 검사로 네트워크 상에서 데이터에 오류가 있는지 확인하기 위한 체크 값을 결정하는 방식
> 

데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC값을 계산하여 데이터에 붙여 전송하고, 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 된다. 이어서 두 값을 비교하고, 이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있다.

- CRC 계산 예시
    
    원본 데이터 : 11010011101100
    
    다항식 : x^3 + x + 1 => 1011 (4비트)
    
    **1단계 데이터 준비**
    
    원본 데이터에 (다항식 비트수 -1) 만큼의 0을 추가한다.
    
    원본 데이터 + (다항식 비트수 - 1)개의 0 : 11010011101100000
    
    **2단계 검증 값 계산**
    
    데이터의 제일 앞자리 가 1비트인 곳에 다항식 비트 1011을 맞춰두고 **XOR 연산**을 계속한다.
    
    ```
    1 1010 0111 0110 0000
    1 011
    0 1100 0111 0110 0000
      1011
      0111 0111 0110 0000
       101 1
    					...
    						0000 0100 (결과값)
    ```
    
     
    
    **3단계 검증**
    
    원본 데이터인 11010011101100 값에 100 비트를 붙여 11010011101100100을 만든 후, 다항식 비트였던 1011을 2단계와 같은 방식으로 XOR 해가면 된다. 결과 값이 0이 되면 CRC 체크 통과
    

### **TTL(IPv4)은 HOP limit(IPv6)로 대체**

> TTL이란? IPv4에서 TTL 필드는 패킷이 네트워크에서 무한 순환하지 않도록 하는 변수이다. 패킷이 네트워크에서 라우터를 거칠 때마다 TTL 값이 1씩 감소되며 값이 0이 되면 패킷이 폐기된다.
> 

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%204.png)

홉 수는 거치게 되는 라우터의 수로 Hop Limit은 홉의 수를 제한하는 것이다.

명칭만 다를 뿐 실제로는 같은 기능을 한다.

### 요약

| 구분 | IPv4 | IPv6 |
| --- | --- | --- |
| 주소 길이 | 32비트 | 128비트 |
| 표시 방법 | 8비트씩 4부분 10진수 표시 | 16비트 8부분 16진수로 표시 |
| 주소 개수 | 약 43억개 | 약 43억*43억*43억*43억 |
| 주소 할당 방식 | A, B, C, D 등의 클래스 단위 비순차 할당 | 네트워크 규모, 단말기수에 따라 순차 할당 |
| 헤더 크기 | 가변 | 고정 |
| 보안 | IPSec 프로토콜 별도 설치 | IPSec 자체 지원 |

### Q. **IPv4와 IPv6 누가 더 빠를까?**

IPv6의 헤더가 더 단순해져서 조금 더 빠르게 데이터를 처리할 수가 있어 보통은 IPv6가 속도가 더 빠르지만 IPv6이 사용하는 더 큰 패킷 크기로 인해 일부 사용 사례에서는 속도가 느려질 수 있다.

### 왜 아직 IPv6를 쓰지 않는 걸까?

IPv4 → IPv6 사용의 근본적인 문제는 **보안**이다. 현재 국내의 대부분을 차지하는 IPv4기반의 보안 시스템은 IPv6로 설정된 모바일 기기, 개인 pc, 서버 등에서 발생되는 해킹 공격을 탐지할 수 없다. 또한 IPv6 환경 변화로 인해 네트워크 상 취약점이 생기게 된다. 

---

## ***IP주소체계 : 3. 클래스풀(Classful IP Addressing)***

> IP주소는 인터넷 주소로 네트워크 주소와 호스트 주소 두 부분으로 나뉜다.
> 

> 네트워크 주소는 호스트들을 모은 네트워크를 지칭하며 네트워크 주소가 동일하면 로컬 네트워크이다. 호스트 주소는 호스트를 구분하기 위한 주소이다.
> 

<aside>
💡 네트워크 호스트(network host)는 컴퓨터 네트워크에 연결된 컴퓨터나 기타 장치이다.

</aside>

### **클래스풀(Classful)**

> 네트워크 주소를 매기고 그에 따라 네트워크의 크기를 다르게 구분하여 클래스를 할당하는 주소 체계이다. 구분하는 기준자(첫, 2, 3옥텟)를 서브넷 마스크라고 한다.
> 

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%205.png)

- 예시
    
    1.0.0.0 ~ 1.255.255.255 => 같은 네트워크이다.
    
    1 : Network Id
    
    뒤에 오는 것 : Host Id
    

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%206.png)

**Class A**

- 네트워크 주소 범위 1~126으로 시작
- 127의 경우 특수 주소(127.0.0.1 = local), 0.0.0.0도 특수 주소이다.
- 한 네트워크당 16777214 호스트 ID(약 1600만개)

**Class B**

- 네트워크 주소 범위 128~191로 시작
- 한 네트워크당 65534 호스트 ID(6만 5천개)

**Class C**

- 네트워크 주소 범위 192~223로 시작
- 한 네트워크당 254 호스트 ID

### **문제점**

> 네트워크의 크기가 작은 경우 큰 네트워크를 필요로 하는 조직은 여러 개를 확보해야 하는 어려움. 작은 네트워크가 필요한 조직의 경우 너무 많은 IP를 가져가므로 IP가 낭비된다.
> 

---

## ***IP주소체계 : 4.클래스리스와 서브넷 마스크, 서브네팅***

> 클래스풀의 단점을 해결하기 위해 클래스리스(Classless)가 나왔다. 클래스로 나누는 것이 아닌, 서브넷 마스크를 중심으로 어디까지가 네트워크 주소고 어디까지가 호스트 주소인지를 나눈다.
> 

- 서브네팅 : 네트워크를 나눈다는 의미
- 서브넷 : 서브네트워크, 쪼개진 네트워크
- 서브넷마스크 : 서브네트워크를 위한 비트마스크

### **서브넷마스크**

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%207.png)

네트워크 주소 부분만 모두 1, 호스트 주소 부분은 0으로 설정해서 나눈다.

Ex) 192.168.50.112 → 255.255.255.0 (서브넷마스크)

192 ~> C class, 네번째 부분이 Host Id로 사용

컴퓨터가 이해하기 쉽도록 네트워크 부분은 모두 1로 변환 (11111111 → 255), 호스트부분은 0

& (AND) 연산자를 통해 네트워크 주소를 알아낸다. **세분화**가 가능하다!

### Q. 10개의 사무실이 있으며 사무실당 12개의 장치를 연결해야 한다면?

한 서브네트워크(서브넷)당 123.12.12.12/28로 16개의 네트워크를 확보해야 16-2=14개 장치까지 가능하다.

즉, 255.255.255.11110000  (네트워크 부분, 호스트 부분 16개)

---

## ***IP주소체계 : 5. 공인IP(public IP)와 사설IP(private IP)와 NAT***

IP주소의 부족을 공인IP(public IP)와 사설IP(private IP)로 나누고 중간에 NAT이라는 기술을 통해 해결한다.

NAT(Network Address Translation)는 패킷이 트래픽 라우팅 장치를 통해 전송되는 동안 패킷의 IP주소를 변경, IP 주소를 다른 IP주소로 매핑하는 방법이다.

![Untitled](4%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%20IP%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A9%20d6f3bb93a8e14f4b86a0dcf69958a18d/Untitled%208.png)

내부에서는 사설 IP를 사용하고 외부와 통신할 때 공인 IP를 사용한다. (중간에 NAT)

NAT를 통해 내부 네트워크 IP가 노출되지 않는 점이 장점이다.
