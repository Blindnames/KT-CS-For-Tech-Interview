네트워크 4 - 1
IP 주소

논리적 주소이며 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호

사실상 MAC 주소를 통해 통신

​

MAC주소

네트워크 인터페이스에 할당된 고유 식별자이며 보통 장치의 NIC에 할당

​

ARP

IP주소를 MAC 주소로 변환

​

RARP

MAC 주소를 IP 주소로 변환


​

ARP의 과정 

1. 해당 IP주소에 맞는 MAC주소를 찾기 위해 해당 데이터를 “브로드캐스팅”을 통해 연결된 네트워크에 있는 장치한테 모두 보냄 

2. 맞는 장치가 있다면 해당 장치는 보낸 장치에게 유니캐스트로 데이터를 전달해 주소를 찾기

IP주소체계 #1: 이진수 이해하기

우리가 평소에 표현하는 수는 0 ~ 9라는 수를 기반으로 수를 표현 :  십진법

123 = 3 * 10 ^ 0 + 2 * 10 ^ 1 + 1 * 10 ^ 2

​

0 과 1, 두개의 숫자로 표현 : 이진법

181 = 10110101

​

IP주소체계 #2: IPv4와 IPv6

IPv4 

32비트로 표현되는 주소체계

2^32개의 주소로 표현

8비트 단위로 점을 찍어 4개로 구분

8비트를 10진수로 표현

→ 이 주소체계만으로는 부족

​

IPv6

128비트로 표현되는 주소체계

2^ 128개의 주소 표현

16비트씩 8개로 구분

16진수로 변환되어 콜론(:)으로 구분

→ 많은 주소 처리가능하며 NAT, 서브네팅이 필요하지 않음

​

IPv4는 체크섬이 있지만 IPv6는 체크섬이 없다. 

IPv4에는 CRC를 통한 손상된 패킷을 확인하고 폐기하는데 쓰는 체크섬필드가 있습니다.

그러나 IPv6는 해당 체크섬필드가 존재하지 않습니다. 

이유는 상위 프로토콜(TCP, UDP)에 체크섬필드가 있기 때문

​

CRC란?

순환중복검사로 네트워크상에서 데이터에 오류가 있는지 확인하기 위한 체크값

​

데이터를 전송하기 전에 주어진 데이터의 값과 데이터 전송이 끝난 후 받은 데이터의 값

두 값을 비교

이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송

​

→ ★ 보통은 IPv6를 사용하는 것이 IPv4보다 속도가 더 빠르지만 

일부 사용사례에서는 속도가 느린 경우도 있습니다.

​

IP주소체계 #3. 클래스풀(Classful IP Addressing) 

IP주소 = 인터넷 주소 → 네트워크주소, 호스트주소

 즉, 두 부분으로 나뉩니다

​

네트워크 주소를 매기고 그에 따라 네트워크의 크기를 다르게 구분하여 클래스를 할당하는 주소체계

구분하는 기준자(1, 2, 3옥텟) :  서브넷마스크


Class A 


2^24 – 2 

네트워크 주소 범위 : 1 ~ 126 로 시작

​

Class B


2^16 – 2 

네트워크 주소 범위 : 128 ~ 191로 시작

​

Class C


2^8 – 2 

네트워크 주소 범위 : 192 ~ 223 로 시작

​

2를 빼는 이유는?

맨 앞자리는 네트워크 주소로 남겨두며 마지막 주소는 브로드캐스팅 주소로 남겨놓습니다. 

​

클래스 풀의 문제점은?

네트워크의 크기가 작은 경우 큰 네트워크를 필요로 하는 조직은 여러개를 확보해야 하는 어려움

작은 네트워크가 필요한 조직의 경우 너무 많은 IP를 가져가므로 IP가 낭비되는 문제점

​

IP주소체계 #4. 클래스리스와 서브넷마스크, 서브네팅 

클래스풀의 단점을 해결하기 위한 클래스리스

​

클래스리스

서브넷마스크를 중심으로 어디까지가 네트워크 주소고 어디까지가 호스트주소인지를 나눔

서브네팅 : 네트워크를 나눈다는 의미 

서브넷 : 서브네트워크, 쪼개진 네트워크

서브넷마스크 

서브네트워크를 위한 비트마스크

네트워크주소부분만 모두 1, 호스트주소부분은 0으로 설정해서 나눕니다. 

​

IP주소체계 #5. 공인IP(public IP)와 사설IP(private IP)와 NAT

IP주소의 부족을 공인IP와 사설IP로 나누고 중간에 NAT이라는 기술을 통해 해결

​

NAT (Network Address Translation)

 패킷이 트래픽 라우팅 장치를 통해 전송되는 동안 패킷의 IP주소를 변경, IP 주소를 다른 IP 주소로 매핑하는 방법

네트워크 4 - 2
HTTP 헤더(header) 

사용자가 HTTP요청을 하게 되면 헤더와 바디를 주고 받습니다.

바디 : 본문

헤더 

바디를 설명하는 정보를 포함해서 여러가지 정보가 담긴 정보묶음

콜론 ':' 으로 서로 구분되는 key - value형태로 설정

HTTP요청을 할 때 일반헤더, 요청헤더, 응답헤더가 자동으로 생성

​

일반헤더 

자원을 요청할 때 해당자원의 출처를 나타내는 URL을 노출시킬지 말지를 정하는 보안정도가 설정되어있는 Referrer Policy 등이 들어갑니다. 

​

요청헤더 

클라이언트가 서버에 요청할 때 클라이언트가 설정하는 또는 자동으로 설정되는 헤더를 말합니다.

​

응답 헤더

서버의 소프트웨어 정보 등이 담깁니다.  대부분의 서버는 일반적으로 해커가 서버에서 어떤 소프트웨어가 사용되고 있는지 알기 어렵게 하기 위해 서버 정보를 숨깁니다. 

DEEP DIVE : HTTP/1.0과 HTTP/1.1의 차이, keep-alive, HOL까지

HTTP/1.0

수명이 짧은 연결

각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계

→ 한번 연결할 때마다 RTT가 늘어나는 문제점

​

HTTP/1.1

 HTTP/1.0의 단점을 보완한 프로토콜

​

HTTP/1.1 특징

1.keep-alive default

데이터를 요청할 때마다 TCP 연결을 한번 해놓고 계속해서 데이터를 받기 가능

keep-alive header 

TCP연결 연결유지시간인 timeout과 최대 요청수 max 조정 가능

​

2. 호스트 헤더

HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 있었습니다. HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경되었으며 항상 호스트를 포함해서 요청하도록 바뀌었습니다.

​

3. 대역폭 최적화

HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것은 불가능했습니다. 이를 다시 다운로드 받을 수 있게 바뀌었습니다.

HTTP/1.1로 발전했음에도 불구하고 서버요청할 때마다 RTT는 계속해서 증가

→ 요청을 줄이기 위한 3가지 기술

​

이미지 스프라이트 

수많은 이미지를 하나의 이미지로 만들어 하나의 이미지만 다운받아놓고 이를 통해 수많은 이미지를 다운받는 듯한 효과

​

2. 코드압축 

코드를 압축해서 서빙

​

3. 이미지 Base64 인코딩 

이미지 파일을 64진법으로 이루어진 문자열로 인코딩해서 이미지 서버에 대한 HTTP 요청을 할 필요가 없음

​

HTTP/1.1의 고질적인 문제 : HOL

HOL(Head Of Line Blocking)

네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능저하현상

DEEP DIVE : HTTP/2와 HTTP/3의 차이

HTTP/2 

2009년 구글은 HTTP/1.1의 한계를 극복하기 위해 SPDY 프로토콜을 개발

​

바이너리 포맷 계층 

애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가

HTTP 2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고 더 작은 메시지가 프레임으로 캡슐화 되어서 전송

​

2. 멀티플렉싱 

단일 TCP연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적 전송

이를 통해 HOL을 해결

​

3. 서버푸시 

서버가 리소스를 클라이언트에 푸시

요청된 html파일과 함께 다른 개체를 별도로전송

만약 요청한 html에 css가 포함되어있다면 별도 요청없이 css를 같이 보내기 가능

​

4. 헤더압축 

HTTP/1.1에서는 무거운 헤더가 있었지만 이를 허프만 인코딩 압축 방법 등으로 압축

똑같은 서버에서 2개의 이미지를 준다고 했을 때 중복되는 헤더는 제외한채 보내고 해당 공통 필드로 헤더를 재구성하며 중복되지 않은 헤더값은 허프만 인코딩 압축 방법으로 압축해 전송

​

5. 우선순위 

서버에서 원하는 순서대로 우선순위를 정해 리소스 전달

HTTP/3 

HTTP/2는 여전히 TCP를 사용하기 때문에 초기 연결에 대한 RTT로 인한 지연시간이라는 문제점

이를 해결한 버전

QUIC(Quick UDP Internet Connections)이라는 계층 위에서 돌아가며, 

UDP 기반으로 돌아 가며 HTTP/2에서 장점이었던 멀티플렉싱 등을 가지고 있으며 초기연결설정시 지연시간 감소라는 대표적 특성을 가지고 있습니다. 


DEEP DIVE : HTTPS와 TLS #1. 암호화

암호화는 승인된 당사자만 정보를 이해할 수 있도록 데이터를 스크램블한 방법

이를 복호화하려면 송신자와 수신자가 서로 동의한 키가 필요

​

스크램블이란

각 단어나 문자를 패턴에 따라 암호화하는 것이 아니라 무작위 방식으로 개별 데이터 비트를 섞는 것을 말합니다.

​

대칭 암호화 

키를 하나만 사용하는 암호화 방법입니다. 

예를 들어 "hello"라는 텍스트를 키로 암호화한다고 해봅시다. 동일한 키로 암호를 해독해서 hello를 반환한 것을 볼 수 있습니다. 

Plaintext + key = ciphertext: hello + 2jd8932kd8 = X5xJCSycg14= 

Ciphertext + key = plaintext: X5xJCSycg14= + 2jd8932kd8 = hello 

일반적으로 사용되는 대칭 암호화 알고리즘은 DES, AES가 있습니다. 

​

비대칭 암호화 

 = 공개키 암호화

공개 키 암호화는 두 개의 다른 키(공개키, 개인키)로 데이터를 암호화하거나 서명하고 키 중 하나인 공개 키를 누구나 사용할 수 있도록 하는 방법

DEEP DIVE : HTTPS와 TLS #2. TLS 핸드셰이크 

클라이언트와 서버가 통신 할 때 TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 합니다

​

1. Client Hello 클라이언트는 TLS버전, 사이퍼슈트와 클라이언트 랜덤값(무작위 문자열), 임시 DH 매개변수를 서버에게 보냅니다. 

​

2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify 

서버는 클라이언트로부터 받은 옵션을 확인합니다. 서버와 클라이언트 모두에서 지원하는 가장 높은 TLS 버전을 식별하며 결정, 사이퍼슈트 지원 여부를 확인합니다. 공개키가 포함된 SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보냅니다. 그리고 클라이언트와 서버 각각 서로 교환한 DH 매개변수를 사용하여 임시 암호 키(세션키)를 생성합니다. 

​

3. Finished

클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신이 시작됩니다.

DH의 경우 타원곡선 DH를 사용합니다.

​

DH 매개변수

Diffie-Hellman을 의미

Diffie-Hellman 알고리즘: 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘

DHE와 타원곡선암호화 방법과 DH를 섞은 ECDHE가 있고 보통 ECDHE를 씁니다.

​

사이퍼슈트

프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며 암호제품군

ex.

TLS_AES_128_GCM_SHA256에는 세 가지 규약이 들어 있음

- TLS는 프로토콜 

- AES_128_GCM은 AEAD 사이퍼 모드 

- SHA256은 해싱 알고리즘 

​

AEAD 사이퍼 모드 

80 AEAD(Authenticated Encryption with Associated Data)는 데이터 암호화 알고리즘

​

해싱 알고리즘 

데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘

​

Q. 해싱알고리즘은 TLS에서 어떻게 쓰이나요? 

1. 인증 생성작업 : 전자 서명을 만드는데 서명되는 메시지를 해싱

2. 인증 확인작업 : 메시지를 복호화해서 해시를 서로 비교해 올바른 메시지인지 확인